{>"index"/}

{<baseContent}
<h1><a id="Linked_Data_Views_0"></a>Linked Data Views</h1>
<h2><a id="Inspiration_1"></a>Inspiration</h2>
<p>A poster advertising a performance has entities like the place or the band, can we produce something like this automatically based on a linked data representation of the performance?</p>
<p>By displaying a page consisting of an entity together with a simple view of its related entities can we produce a more informative view of a dataset.</p>
<p>In some ways this idea can be thought of as a Web Templating System to present entities on web pages. The default configuration creates simple representations with more specific views being generated by adding or creating additional templates. A good system would allow these templates to be usable on other linked data based websites.</p>
<h2><a id="Demo_8"></a>Demo</h2>
<p>Note: This is still a work in progress but enough exists to demonstrate the main ideas.</p>
<p>The demonstration site is here: <a href="http://performances.annalist.net">http://performances.annalist.net</a><br>
The code is available at: <a href="http://bitbucket.com/akademy/ldview">http://bitbucket.com/akademy/ldview</a></p>
<h2><a id="Work_done_14"></a>Work done</h2>
<p>Each entity has its own page. This entity is called the “main” one and displayed using the “main-template”. The related entities are displayed using “mini-templates”.</p>
<h3><a id="Storing_relations_18"></a>Storing relations</h3>
<p>We currently collect together and cache the relationships between entities within a single local graph, no external data is retrieved (beyond that stored in Annalist). We record both forward and backward links, e.g. if entity A states a relationship to B and entity C states a relationship to A, then A holds both a A-B link and an A-C link marked as “reversed”.</p>
<p>Each of these links also records the “path” of predicates to that entity, e.g. if A is related to B by:</p>
<pre><code>&lt;A&gt; &lt;http://erlangen-crm.org/current/P7_took_place_at&gt; &lt;B&gt;
</code></pre>
<p>then the path contains this one predicate “<a href="http://erlangen-crm.org/current/P7_took_place_at%E2%80%9D">http://erlangen-crm.org/current/P7_took_place_at”</a>. Alternatively B could be related as:</p>
<pre><code>&lt;A&gt;  &lt;http://erlangen-crm.org/efrbroo/R25F_performed_r&gt;  _:b0
_:b0  &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#first&gt;  _:b3
_:b3  &lt;http://erlangen-crm.org/efrbroo/R25F_performed&gt;   &lt;B&gt;
</code></pre>
<p>the path would then contain both “<a href="http://erlangen-crm.org/efrbroo/R25F_performed_r%E2%80%9D">http://erlangen-crm.org/efrbroo/R25F_performed_r”</a> and “<a href="http://erlangen-crm.org/efrbroo/R25F_performed%E2%80%9D">http://erlangen-crm.org/efrbroo/R25F_performed”</a> (The list “fluff” is not needed). This works fine when each entity stands by itself, but additional work still needs to be done to capture qualified relations, for instance when a performance has an agent which had a particular role (Bob played the Clarinet in Performance A):</p>
<pre><code>&lt;A&gt;  &lt;http://www.w3.org/ns/prov#qualifiedAssociation&gt;  _:b0
_:b0  &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#first&gt;  _:b3
_:b3  &lt;http://www.w3.org/ns/prov#agent&gt;   &lt;B_Bob&gt;
_:b3  &lt;http://www.w3.org/ns/prov#hadRole&gt;  &lt;C_Clarinetist&gt;
</code></pre>
<p>It would currently be wrongly recorded as two unrelated links, one for the agent and one for the role. (For instance see “Associated”: <a href="http://performances.annalist.net/attrs/http%3A%2F%2Fannalist.net%2Fannalist_sitedata%2Fc%2FCarolan_Guitar%2Fd%2FPerformance%2FCaroling_Carolan">http://performances.annalist.net/attrs/http%3A%2F%2Fannalist.net%2Fannalist_sitedata%2Fc%2FCarolan_Guitar%2Fd%2FPerformance%2FCaroling_Carolan</a> )</p>
<p>Once we have a predicate path we can present these relations as we see fit. The demo website has a hierarchy of HTML sections and headings to highlight the relationship to the main entity. A heading’s text, by default, is just the predicate string simplified, but friendlier names can be added into a configuration file. We highlight a reverse link (a relationship coming from another entity) be adding “reversed” to the displayed predicate text, but this can also be changed in the configuration file.</p>
<h3><a id="The_Main_and_the_Mini_Templates_43"></a>The Main and the Mini Templates</h3>
<h4><a id="Selection_45"></a>Selection</h4>
<p>We choose a template based on an entity’s class. Currently this uses a value stored in Annalist (annal:type_id) to simplify the selection process, but ultimately a template will be selected by the most specific class available (as defined, for example, by a hierarchy of rdfs:subClassOf ).</p>
<p>For instance, if we had an entity of class dbo:MusicalArtist but no specific template written to display that then we can move upwards through the class hierarchy till we found an available template that is still compatible with the data:</p>
<p>dbo:MusicalArtist -&gt; dbo:Artist -&gt; dbo:Person -&gt; dbo:Agent -&gt; owl:Thing</p>
<p>A top level “generic” template may need to be used if there is no matching template. This may only show a title or even just an ID.</p>
<p>It should also be possible to select a template based on what class an entity “looks like”, for instance, if it has a property geo:lat assume a template based on a class of Place would be suitable. This is yet to be implemented.</p>
<p>Additionally, a predicate can have a list of entities rather than a single one. Currently a list is represented by a list of separate mini-templates but future version could allow for a single mini-template to show multiple entities. For instance, a list of places can be shown on a single map.</p>
<h4><a id="Pulling_together_templates_58"></a>Pulling together templates</h4>
<p>The templates are stored as Dust templates. The master website template (that which holds the structure of each page including menus etc. ) is passed to the browser in the initial page request. The main-template and mini-templates (and their related data) are then requested using Javascript.</p>
<p>The structure of the master template is completely flexible but the example website has a simple layout to highlight how the system works (and doesn’t necessarily represent a good design…). It consists of three columns with the main-template sitting across two columns at the top. The related entities are displayed in the columns.</p>
<p>Each column has a class of “entities-section” which marks it as an area where related entities will load. It is also possible to define where specific related entities will appear based on their predicate, set data-predicate equal to the predicate.</p>
<pre><code>&lt;div data-predicate=”http://erlangen-crm.org/current/P7_took_place_at”&gt;&lt;/div&gt;
</code></pre>
<p>If nothing is specified the entities will be added at the end of &lt;body&gt;.</p>
<p>The mini-template are then used to fill the entities-section. These are simple views of each related entity’s data, for example a person entity might only show a photo, a place entity might only show a map.</p>
<p>If a specific position has not been set (using data-predicate), then the position and order of each related entity (within the marked areas) is determined by the order they were extracted from the database and then the highest free space (i.e. nearest the page top) is used. In the demo website this means the shortest column will be used. (A few caveats on this: currently there is no paging of the list of entities under a particular predicate therefore one column can be much taller than the others, neither is there any way to split a list into several columns.)</p>
<p>Note: The example website has a few dummy mini-templates which are “hacked” in to show the potential of the system, each entity does not have the required data to show these enhanced views: The place entities do not have latitude and longitude but the templates display a map; the artifact entity does not have a photo but the mini-template shows one. (See: <a href="http://performances.annalist.net/attrs/http%3A%2F%2Fannalist.net%2Fannalist_sitedata%2Fc%2FCarolan_Guitar%2Fd%2FPerformance%2FCaroling_Carolan">http://performances.annalist.net/attrs/http%3A%2F%2Fannalist.net%2Fannalist_sitedata%2Fc%2FCarolan_Guitar%2Fd%2FPerformance%2FCaroling_Carolan</a> )</p>
<h4><a id="Switching_pages_75"></a>Switching pages</h4>
<p>Future work. To preserve a user’s context on page change it would be best if the entities “reconfigured” (i.e. moved, appeared or disappeared) as defined in the new page. (This proved rather tricky given the flexible templating system, so to show the idea I only implemented the movement of the entity that is selected by a user. Further work is needed to determine if this would actually be more confusing…)</p>
<h2><a id="Technical_details_78"></a>Technical details</h2>
<p>This works from the Annalist data. The JSON-LD files are stored in a Fuseki datastore. The relations are then pulled out and stored in Mongo (this isn’t technically necessary but it was far easier and quicker to do it this way, although I admit my sparql-fu is limited).</p>
<p>The website runs under NodeJS. When an entity’s page is requested the main entity data is extracted from the database and the page displayed. A Javascript function then requests all the related entities, and then requests all mini-templates needed for those entities. All the data and templates are cached on the client.</p>
<h2><a id="Live_performance_83"></a>Live performance</h2>
<p>The templating system is flexible enough to handle changes to entities as they occur on the webpage but the ideas that follow have not yet been implemented.</p>
<p>Using socket communication between the server and client we can register to receive changes to a page’s data as they occur. Entity sections are then updated using the templates already obtained.</p>
<p>Database changes on the server are triggered by some separate system which will need to monitor the data’s source, in the case of Annalist the jsonld files can be checked then indexed when needed.</p>

{/baseContent}